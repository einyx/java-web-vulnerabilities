package de.marko.pentest.db;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaDelete;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;
import org.apache.commons.dbcp2.BasicDataSource;
import org.hibernate.cfg.AvailableSettings;

/**
 * DatabaseJPAConnector represents a JPA eqvivalent to the Hibernate
 *
 * @author marko
 * @version 05.01.2018
 */
public class DatabaseJPAConnector {

    /**
     * actual instance of database
     */
    private static DatabaseJPAConnector instance = null;

    /**
     * database connection
     */
    private EntityManagerFactory entityManagerFactory = null;

    /**
     * Default EntityManager of {@link DatabaseJPAConnector}
     */
    private static String defaultEntityManager = null;

    /**
     * private Constructor
     *
     * @param entityManagerFactory actual database connection session
     */
    private DatabaseJPAConnector(EntityManagerFactory entityManagerFactory,
        String defaultEntityManager) {
        this.entityManagerFactory = entityManagerFactory;
        this.defaultEntityManager = defaultEntityManager;
    }

    // TODO connect as getInstance --> thread safe implementation by using Double-checked locking
    // better way see:
    // http://www.javaworld.com/article/2073352/core-java/simply-singleton.html?page=2

    /**
     * Creates a new connection to database.
     *
     * @return Returns a new {@link DatabaseJPAConnector} object.
     */
    public static DatabaseJPAConnector connect(final String defaultEntityManager) {

        if (instance == null) {
            synchronized (DatabaseJPAConnector.class) {
                if (instance == null) {
                    EntityManagerFactory emf = Persistence
                        .createEntityManagerFactory(defaultEntityManager);
                    instance = new DatabaseJPAConnector(emf, defaultEntityManager);
                }
            }
        }
        return instance;
    }

    /**
     * Creates a new connection to database.
     *
     * @return Returns a new {@link DatabaseJPAConnector} object.
     */
    public static DatabaseJPAConnector connect(final String defaultEntityManager,
        final Properties props, final BasicDataSource dbcpDataSource) {

        if (instance == null) {
            synchronized (DatabaseJPAConnector.class) {
                if (instance == null) {
                    // This line will tell hibernate (JPA) to use DBCP
                    props.put(AvailableSettings.DATASOURCE, dbcpDataSource);

                    EntityManagerFactory emf = Persistence
                        .createEntityManagerFactory(defaultEntityManager, props);
                    instance = new DatabaseJPAConnector(emf, defaultEntityManager);
                }
            }
        }
        return instance;
    }

    /**
     * Creates a new connection to database.
     *
     * @return Returns a new {@link DatabaseJPAConnector} object.
     */
    public static DatabaseJPAConnector connect() {

        if (defaultEntityManager == null) {
            throw new RuntimeException();
        }

        if (instance == null) {
            synchronized (DatabaseJPAConnector.class) {
                if (instance == null) {
                    EntityManagerFactory emf = Persistence
                        .createEntityManagerFactory(defaultEntityManager);
                    instance = new DatabaseJPAConnector(emf, defaultEntityManager);
                }
            }
        }
        return instance;
    }

    /**
     * Reads all elements from the table.
     *
     * @param clazz class type of result elements
     * @param <T> generic class type
     * @return Returns a list with all elements of the table.
     */
    public <T> List<T> entities(Class<T> clazz) {
        EntityManager entityManager = this.entityManagerFactory.createEntityManager();
        EntityTransaction tx = null;

        try {
            tx = entityManager.getTransaction();
            tx.begin();

            CriteriaBuilder cb = entityManager.getCriteriaBuilder();
            CriteriaQuery<T> query = cb.createQuery(clazz);
            Root<T> statement = query.from(clazz);
            query.select(statement);
            TypedQuery<T> q = entityManager.createQuery(query);

            List<T> result = q.getResultList();
            tx.commit();
            return result;
        } catch (RuntimeException ex) {
            if (tx != null && tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException(ex);
        } finally {
            entityManager.close();
        }
    }

    /**
     * Merge an object in database
     */
    public void merge(Object object) {

        EntityManager entityManager = this.entityManagerFactory.createEntityManager();
        EntityTransaction tx = null;

        try {
            tx = entityManager.getTransaction();
            tx.begin();
            entityManager.merge(object);
            tx.commit();
        } catch (RuntimeException ex) {
            if (tx != null && tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException(ex);
        } finally {
            entityManager.close();
        }
    }

    /**
     * Persist an object in database
     */
    public void persist(Object object) {

        EntityManager entityManager = this.entityManagerFactory.createEntityManager();
        EntityTransaction tx = null;

        try {
            tx = entityManager.getTransaction();
            tx.begin();
            entityManager.persist(object);
            tx.commit();
        } catch (RuntimeException ex) {
            if (tx != null && tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException(ex);
        } finally {
            entityManager.close();
        }
    }

    /**
     * Persist a {@link List} of objects in database
     */
    public void persist(List<Object> objects) {

        EntityManager entityManager = this.entityManagerFactory.createEntityManager();
        EntityTransaction tx = null;

        try {
            tx = entityManager.getTransaction();
            tx.begin();
            for (Object o : objects) {
                entityManager.persist(o);
            }
            tx.commit();
        } catch (RuntimeException ex) {
            if (tx != null && tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException(ex);
        } finally {
            entityManager.close();
        }
    }

    /**
     * delete all elements from the table.
     *
     * @param clazz class type of result elements
     * @param <T> generic class type
     * @return Returns a list with all elements of the table.
     */
    public <T> int deleteAll(Class<T> clazz) {
        EntityManager entityManager = this.entityManagerFactory.createEntityManager();
        EntityTransaction tx = null;

        try {
            tx = entityManager.getTransaction();
            tx.begin();
            CriteriaBuilder cb = entityManager.getCriteriaBuilder();
            CriteriaDelete<T> query = cb.createCriteriaDelete(clazz);
            Root<T> statement = query.from(clazz);
            int result = entityManager.createQuery(query).executeUpdate();
            tx.commit();
            return result;
        } catch (RuntimeException ex) {
            if (tx != null && tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException(ex);
        } finally {
            entityManager.close();
        }
    }

    /**
     * Deletes an object from its table.
     *
     * @param object object to delete
     */
    public void delete(Object object) {

        EntityManager entityManager = this.entityManagerFactory.createEntityManager();
        EntityTransaction tx = null;

        try {
            tx = entityManager.getTransaction();
            tx.begin();

            entityManager
                .remove(entityManager.contains(object) ? object : entityManager.merge(object));

            tx.commit();
        } catch (RuntimeException ex) {
            if (tx != null && tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException(ex);
        } finally {
            entityManager.close();
        }
    }

    /**
     * Reads the object with given id from database.
     *
     * @param clazz class type of result elements
     */
    public <T> T findById(Class<T> clazz, Long id) {

        EntityManager entityManager = this.entityManagerFactory.createEntityManager();
        EntityTransaction tx = null;

        try {
            tx = entityManager.getTransaction();
            tx.begin();
            T object = entityManager.find(clazz, id);
            tx.commit();
            return object;
        } catch (RuntimeException ex) {
            if (tx != null && tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException(ex);
        } finally {
            entityManager.close();
        }
    }

    /**
     * * Creates an query object to read out elements from database.
     *
     * @param query sql statement
     * @param clazz class type of result elements
     * @param arguments map with arguments
     * @param <T> generic class type
     * @return Returns a list with all elements, which fitting sql statement.
     */
    public <T> List<T> getResultsFromJPQLSelectQuery(String query, Class<T> clazz,
        Map<String, Object> arguments) {

        if (!query.toLowerCase().startsWith("select")) {
            throw new IllegalArgumentException("No select statement given by caller.");
        }

        EntityManager entityManager = this.entityManagerFactory.createEntityManager();
        EntityTransaction tx = null;

        try {
            tx = entityManager.getTransaction();
            tx.begin();

            TypedQuery<T> q = entityManager.createQuery(query, clazz);
            for (Map.Entry<String, Object> entry : arguments.entrySet()) {
                q.setParameter(entry.getKey(), entry.getValue());
            }

            List<T> results = q.getResultList();

            tx.commit();
            return results;
        } catch (RuntimeException ex) {
            if (tx != null && tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException(ex);
        } finally {
            entityManager.close();
        }
    }

    /**
     * Creates an query object from a given sql select query by using createNativeQuery.
     *
     * ATTENTION! This function is affected against SQL injection.
     *
     * @param query sql select query string
     * @return Returns a list with all elements, which fitting sql statement.
     */
    public <T> List<T> nativeSelectQuery(String query) {

        if (!query.toLowerCase().startsWith("select")) {
            throw new IllegalArgumentException("No select statement given by caller.");
        }

        EntityManager entityManager = this.entityManagerFactory.createEntityManager();
        EntityTransaction tx = null;

        try {
            tx = entityManager.getTransaction();
            tx.begin();

            Query q = entityManager.createNativeQuery(query);
            List<T> results = q.getResultList();

            tx.commit();
            return results;
        } catch (RuntimeException ex) {
            if (tx != null && tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException(ex);
        } finally {
            entityManager.close();
        }
    }

    /**
     * Creates an query object from a given sql select query by using createNativeQuery.
     *
     * ATTENTION! This function is affected against SQL injection.
     *
     * @param query sql select query string
     * @param clazz class type of result elements
     * @param <T> generic class type
     * @return Returns a list with all elements, which fitting sql statement.
     */
    public <T> List<T> nativeSelectQuery(String query, Class<T> clazz) {

        if (!query.toLowerCase().startsWith("select")) {
            throw new IllegalArgumentException("No select statement given by caller.");
        }

        EntityManager entityManager = this.entityManagerFactory.createEntityManager();
        EntityTransaction tx = null;

        try {
            tx = entityManager.getTransaction();
            tx.begin();
            Query q = entityManager.createNativeQuery(query, clazz);
            List<T> results = q.getResultList();
            tx.commit();
            return results;
        } catch (RuntimeException ex) {
            if (tx != null && tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException(ex);
        } finally {
            entityManager.close();
        }
    }

    /**
     * Close the connection to database.
     */
    public void close() {

        if (this.entityManagerFactory.isOpen()) {
            this.entityManagerFactory.close();
        }
    }

}
